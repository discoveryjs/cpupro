// Process profiles generated by a combination of the following commands:
//
//   > node --prof /path/to/script.js
//   > node --prof-process -preprocess isolate*.log > v8log.json
//
// Useful flags to use with --prof:
//
//   --prof-sampling-interval – interval for samples in microseconds (default is 1000)
//   --log-deopt – include
//
// Recomended set of options to capture a v8 log:
//
//   > node --prof --log-deopt --prof-sampling-interval=250 ...
//

import type { CallFrame, CallNode, V8LogProfile } from './v8-log-processed/types.js';
import type { V8CpuProfile, V8CpuProfileCallFrameCodes, V8CpuProfileScript } from '../types.js';
import jora from 'jora'; // FIXME: temporary? to calc a median only
import { processTicks } from './v8-log-processed/ticks.js';
import { processScriptFunctions } from './v8-log-processed/functions.js';
import { createCallFrames } from './v8-log-processed/call-frames.js';
import { processCallFramePositions } from './v8-log-processed/positions.js';
import { processFunctionCodes } from './v8-log-processed/codes.js';

export function isV8LogProfile(data: unknown): data is V8LogProfile {
    const maybe = data as Partial<V8LogProfile>;

    return (
        Array.isArray(maybe.code) &&
        Array.isArray(maybe.functions) &&
        Array.isArray(maybe.ticks)
    );
}

function normalizeUrl(url: string) {
    let protocol = url.match(/^([a-z\-]+):/i)?.[1] || '';

    if (protocol.length === 1 && protocol >= 'A' && protocol <= 'Z') {
        protocol = '';
        url = url.slice(2);
    }

    if (protocol === '' && /^[\\/]/.test(url)) {
        return 'file://' + url.replace(/\\/g, '/');
    }

    return url;
}

function processUrls(scripts: (V8CpuProfileScript | null)[], callFrames: CallFrame[]) {
    for (const script of scripts) {
        if (script !== null && script.url !== '') {
            script.url = normalizeUrl(script.url);
        }
    }

    for (const callFrame of callFrames) {
        if (callFrame.scriptId !== 0) {
            callFrame.url = scripts[callFrame.scriptId]?.url || '';
        }
    }
}

function collectUsedCallFrames(
    callFrames: CallFrame[],
    nodes: CallNode<number>[],
    callFrameCodes: V8CpuProfileCallFrameCodes[]
) {
    const usedCallFrames: CallFrame[] = [];
    const packedCallFrameIndexMap = new Int32Array(callFrames.length);
    const getPackedCallFrameIndex = (callFrameIndex: number) => {
        let packedIndex = packedCallFrameIndexMap[callFrameIndex];

        if (packedIndex === 0) {
            packedIndex = usedCallFrames.length;
            packedCallFrameIndexMap[callFrameIndex] = packedIndex;
            usedCallFrames.push(callFrames[callFrameIndex]);
        }

        return packedIndex;
    };

    for (const node of nodes) {
        node.callFrame = getPackedCallFrameIndex(node.callFrame);
    }

    for (const callFrameCode of callFrameCodes) {
        callFrameCode.callFrame = getPackedCallFrameIndex(callFrameCode.callFrame);

        for (const code of callFrameCode.codes) {
            for (let i = 0; i < code.fns.length; i++) {
                code.fns[i] = getPackedCallFrameIndex(code.fns[i]);
            }
        }
    }

    return usedCallFrames;
}

export function convertV8LogIntoCpuProfile(v8log: V8LogProfile): V8CpuProfile {
    const { functions, functionsIndexMap, scripts } = processScriptFunctions(v8log.functions, v8log.code, v8log.scripts);
    const { callFrames, callFrameIndexByVmState, callFrameIndexByFunction, callFrameIndexByCode } = createCallFrames(v8log.code, functions, functionsIndexMap);
    const positionsByCode = processCallFramePositions(v8log.code, v8log.functions, callFrameIndexByCode);
    const callFrameCodes = processFunctionCodes(v8log.code, callFrameIndexByCode, positionsByCode, callFrameIndexByFunction);
    const { nodes, samples, timeDeltas, samplePositions, lastTimestamp } = processTicks(
        v8log.ticks,
        callFrames,
        callFrameIndexByVmState,
        callFrameIndexByCode,
        positionsByCode
    );
    const nodeCallFrames = collectUsedCallFrames(callFrames, nodes, callFrameCodes);
    const samplesInterval = jora.methods.median(timeDeltas);

    processUrls(scripts, callFrames);

    return {
        startTime: 0,
        endTime: lastTimestamp + samplesInterval,
        nodes,
        samples,
        timeDeltas,
        // cpupro extensions
        _samplesInterval: samplesInterval,
        _samplePositions: samplePositions,
        _scripts: scripts.filter(script => script !== null),
        _callFrames: nodeCallFrames,
        _callFrameCodes: callFrameCodes,
        _heap: v8log.heap
    };
}
