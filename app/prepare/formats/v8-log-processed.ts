// Process profiles generated by the following commands:
//
//   > node --prof /path/to/script.js
//   > node --prof-process -preprocess isolate*.log > v8log.json
//
// It can also consume extended datasets produced by the CPUpro V8 log decoder.
//
// The --prof flag enables CPU profiling and implicitly sets --log and --log-code.
// Effectively, --prof expands to:
//   --prof --log --log-code --log-source-code --log-position-code
//
// Useful flags with --prof/--log:
//
//   --prof-sampling-interval   Sampling interval in microseconds (default: 1000)
//   --log-deopt                Include deoptimization events
//   --log-code                 Include code events (code-create, code-move, etc.);
//                              implicitly enables --log-source-code and --log-position-code
//   --log-source-code          Include script sources
//   --log-position-code        Include code position tables
//   --log-code-disassemble     Include code disassembly; implicitly enables --log-code
//
// Note: To disable an implicitly enabled flag, use the `--no-` prefix, e.g. `--no-log-code`
//
// Recommended set of options to capture a V8 log:
//
//   > node --prof --log-deopt --prof-sampling-interval=250 ...
//

import type { CallFrame, CallNode, V8LogProfile } from './v8-log-processed/types.js';
import type { V8CpuProfile, V8CpuProfileCallFrameCodes, V8CpuProfileScript } from '../types.js';
import jora from 'jora'; // FIXME: temporary? to calc a median only
import { processFunctions } from './v8-log-processed/functions.js';
import { createCallFrames } from './v8-log-processed/call-frames.js';
import { processCodes } from './v8-log-processed/codes.js';
import { processCodePositionTables } from './v8-log-processed/positions.js';
import { processTicks } from './v8-log-processed/ticks.js';

export function isV8LogProfile(data: unknown): data is V8LogProfile {
    const maybe = data as Partial<V8LogProfile>;

    return (
        Array.isArray(maybe.code) &&
        Array.isArray(maybe.functions) &&
        Array.isArray(maybe.ticks)
    );
}

function updateCallFramesUrl(callFrames: CallFrame[], scripts: (V8CpuProfileScript | null)[]) {
    for (const callFrame of callFrames) {
        if (callFrame.scriptId !== 0) {
            callFrame.url = scripts[callFrame.scriptId]?.url || '';
        }
    }
}

function collectUsedCallFrames(
    callFrames: CallFrame[],
    nodes: CallNode<number>[],
    callFrameCodes: V8CpuProfileCallFrameCodes[]
) {
    const usedCallFrames: CallFrame[] = [];
    const usedCallFrameIndexMap = new Int32Array(callFrames.length);
    const getUsedCallFrameIndex = (callFrameIndex: number) => {
        let packedIndex = usedCallFrameIndexMap[callFrameIndex];

        if (packedIndex === 0) {
            packedIndex = usedCallFrames.length;
            usedCallFrameIndexMap[callFrameIndex] = packedIndex;
            usedCallFrames.push(callFrames[callFrameIndex]);
        }

        return packedIndex;
    };

    for (const node of nodes) {
        node.callFrame = getUsedCallFrameIndex(node.callFrame);
    }

    for (const callFrameCode of callFrameCodes) {
        callFrameCode.callFrame = getUsedCallFrameIndex(callFrameCode.callFrame);

        for (const code of callFrameCode.codes) {
            for (let i = 0; i < code.fns.length; i++) {
                code.fns[i] = getUsedCallFrameIndex(code.fns[i]);
            }
        }
    }

    return usedCallFrames;
}

export function convertV8LogIntoCpuProfile(v8log: V8LogProfile): V8CpuProfile {
    const { functions, functionIndexMap, scripts } = processFunctions(v8log.functions, v8log.code, v8log.scripts);
    const { callFrames, callFrameIndexByVmState, callFrameIndexByCode, callFrameIndexByV8logFunction } = createCallFrames(
        v8log.code,
        functions,
        functionIndexMap
    );
    const positionTableByCode = processCodePositionTables(v8log.code, callFrameIndexByV8logFunction);
    const callFrameCodes = processCodes(v8log.code, callFrameIndexByCode, positionTableByCode);
    const { nodes, samples, timeDeltas, samplePositions, lastTimestamp } = processTicks(
        v8log.ticks,
        callFrameIndexByVmState,
        callFrameIndexByCode,
        positionTableByCode
    );
    const usedCallFrames = collectUsedCallFrames(callFrames, nodes, callFrameCodes);
    const samplesInterval = jora.methods.median(timeDeltas);

    updateCallFramesUrl(usedCallFrames, scripts);

    return {
        startTime: 0,
        endTime: lastTimestamp + samplesInterval,
        nodes,
        samples,
        timeDeltas,
        // cpupro extensions
        _samplesInterval: samplesInterval,
        _samplePositions: samplePositions,
        _scripts: scripts.filter(script => script !== null),
        _callFrames: usedCallFrames,
        _callFrameCodes: callFrameCodes,
        _heap: v8log.heap
    };
}
