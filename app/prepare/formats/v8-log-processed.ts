// Process profiles generated by a combination of the following commands:
//
//   > node --prof /path/to/script.js
//   > node --prof-process -preprocess isolate*.log > v8log.json
//
// Useful flags to use with --prof:
//
//   --prof-sampling-interval – interval for samples in microseconds (default is 1000)
//   --log-deopt – include
//
// Recomended set of options to capture a v8 log:
//
//   > node --prof --log-deopt --prof-sampling-interval=250 ...
//

import type { CallFrame, CallNode, V8LogCode, V8LogFunction, V8LogProfile } from './v8-log-processed/types.js';
import type { V8CpuProfile, V8CpuProfileScript } from '../types.js';
import jora from 'jora'; // FIXME: temporary? to calc a median only
import { processTicks } from './v8-log-processed/ticks.js';
import { processScriptFunctions } from './v8-log-processed/functions.js';
import { createCallFrames } from './v8-log-processed/call-frames.js';
import { processCodePositions } from './v8-log-processed/positions.js';
import { processScripts } from './v8-log-processed/scripts.js';
import { processFunctionCodes } from './v8-log-processed/codes.js';

export function isV8LogProfile(data: unknown): data is V8LogProfile {
    const maybe = data as Partial<V8LogProfile>;

    return (
        Array.isArray(maybe.code) &&
        Array.isArray(maybe.functions) &&
        Array.isArray(maybe.ticks)
    );
}

function processPositions(
    codes: V8LogCode[],
    functions: V8LogFunction[],
    callFrameIndexByCode: Uint32Array
) {
    const positionsByCode = processCodePositions(codes);

    // replace function index in inline info for a call frame index (first code in function's codes)
    for (const positions of positionsByCode) {
        if (positions === null || !positions.inlined) {
            continue;
        }

        for (let i = 0; i < positions.inlined.length; i += 3) {
            const callFrameIndex = callFrameIndexByCode[functions[positions.inlined[i]].codes[0]];

            if (typeof callFrameIndex !== 'number') {
                throw new Error('Can\'t resolve call frame for an inlined function');
            }

            positions.inlined[i] = callFrameIndex;
        }
    }

    return positionsByCode;
}

function normalizeUrl(url: string) {
    let protocol = url.match(/^([a-z\-]+):/i)?.[1] || '';

    if (protocol.length === 1 && protocol >= 'A' && protocol <= 'Z') {
        protocol = '';
        url = url.slice(2);
    }

    if (protocol === '' && /^[\\/]/.test(url)) {
        return 'file://' + url.replace(/\\/g, '/');
    }

    return url;
}

function processUrls(scripts: (V8CpuProfileScript | null)[], callFrames: CallFrame[]) {
    for (const script of scripts) {
        if (script !== null && script.url !== '') {
            script.url = normalizeUrl(script.url);
        }
    }

    for (const callFrame of callFrames) {
        if (callFrame.scriptId !== 0) {
            callFrame.url = scripts[callFrame.scriptId]?.url || '';
        }
    }
}

function collectCallFramesFromNodes(nodes: CallNode<number>[], callFrames: CallFrame[]) {
    const nodeCallFrames: CallFrame[] = [];
    const packedCallFrameIndex = new Int32Array(callFrames.length);

    for (const node of nodes) {
        const callFrameIndex = node.callFrame;
        const callFrame = callFrames[callFrameIndex];
        let nodeCallFramesIndex = packedCallFrameIndex[callFrameIndex];

        if (nodeCallFramesIndex === 0) {
            nodeCallFramesIndex = nodeCallFrames.length;
            packedCallFrameIndex[callFrameIndex] = nodeCallFramesIndex;
            nodeCallFrames.push(callFrame);
        }

        node.callFrame = /* callFrame ||*/ nodeCallFramesIndex;
    }

    return nodeCallFrames;
}

export function convertV8LogIntoCpuProfile(v8log: V8LogProfile): V8CpuProfile {
    const scripts = processScripts(v8log.scripts);
    const functions = processScriptFunctions(v8log.functions, v8log.code, scripts);
    const functionCodes = processFunctionCodes(v8log.functions, v8log.code);
    const { callFrames, callFrameIndexByVmState, callFrameIndexByCode } = createCallFrames(functions, v8log.code);
    const positionsByCode = processPositions(v8log.code, v8log.functions, callFrameIndexByCode);
    const { nodes, samples, timeDeltas, samplePositions, lastTimestamp } = processTicks(
        v8log.ticks,
        callFrames,
        callFrameIndexByVmState,
        callFrameIndexByCode,
        positionsByCode
    );
    const nodeCallFrames = collectCallFramesFromNodes(nodes, callFrames);
    const samplesInterval = jora.methods.median(timeDeltas);

    processUrls(scripts, callFrames);

    return {
        startTime: 0,
        endTime: lastTimestamp + samplesInterval,
        nodes,
        samples,
        timeDeltas,
        // cpupro extensions
        _samplesInterval: samplesInterval,
        _samplePositions: samplePositions,
        _scripts: scripts.filter(script => script !== null),
        _functions: functions,
        _functionCodes: functionCodes,
        _callFrames: nodeCallFrames,
        _heap: v8log.heap
    };
}
