// Insprired by https://github.com/jlfwong/speedscope/blob/main/src/import/v8proflog.ts

// This imports profiles generated by a combination of the following commands:
//
//    node --prof /path/to/my/script.js
//    node --prof-process -preprocess isolate*.log > profile.v8log.json

import { V8CpuProfile, V8CpuProfileScriptFunction, V8CpuProfileScript } from '../types.js';

interface Code {
    name: string;
    type: 'CODE' | 'CPP' | 'JS' | 'SHARED_LIB';
    timestamp?: number;
    kind?:
        | 'Bultin'
        | 'BytecodeHandler'
        | 'Handler'
        | 'KeyedLoadIC'
        | 'KeyedStoreIC'
        | 'LoadGlobalIC'
        | 'LoadIC'
        | 'Opt'
        | 'StoreIC'
        | 'Stub'
        | 'Unopt'
        | 'Ignition'
        | 'Baseline'
        | 'Sparkplug'
        | 'Maglev'
        | 'Turboprop'
        | 'Turbofan'
        | 'Builtin'
        | 'RegExp';
    func?: number;
    tm?: number;
    source?: CodeSource;
}

interface CodeSource {
    script: number;
    start: number;
    end: number;
    positions: string;
    inlined: string;
    fns: number[];
}

interface ProfileFunction {
    name: string;
    codes: number[];
}

interface Tick {
    tm: number;  // timestamp
    vm: number;  // vm state
    s: number[]; // stack
}

interface Script {
    id: number;
    url: string;
    source: string;
}

interface V8LogProfile {
    code: Code[];
    functions: ProfileFunction[];
    ticks: Tick[];
    scripts: Script[];
}

interface CodeCallFrameInfo {
    name: string;
    file?: string; // file path
    line?: number;
    column?: number;
    lowlevel?: boolean;
}

type CallFrame = {
    scriptId: number;
    functionId?: number | null;
    functionName: string;
    url: string;
    lineNumber: number;
    columnNumber: number;
}

type Node = {
    id: number;
    callFrame: CallFrame;
    children: number[];
}

type ParseJsNameResult = {
    functionName: string;
    scriptUrl: string;
    line: number;
    column: number;
}

export const VM_STATE_JS = 0;
export const VM_STATE_GC = 1;
export const VM_STATE_OTHER = 5;
export const VM_STATE_EXTERNAL = 6;
export const VM_STATE_IDLE = 7;
export const vmState = [
    'js',
    'garbage collector',
    'parser',
    'compiler bytecode',
    'compiler',
    'other',
    'external',
    'idle',
    'atomics wait',
    'logging'
] as const;

function findBalancePair(str: string, offset: number, pattern: string) {
    const stack: string[] = [];
    for (let i = offset; i < str.length; i++) {
        if (stack.length === 0) {
            if (str[i] === pattern) {
                return i;
            }
        } else if (stack[stack.length - 1] === str[i]) {
            stack.pop();
            continue;
        }

        switch (str[i]) {
            case '<': stack.push('>'); break;
            case '(': stack.push(')'); break;
            case '[': stack.push(']'); break;
        }
    }

    return str.length;
}

function cleanupInternalName(name: string) {
    // cut off ::(anonymous namespace)
    name = name.replace(/::\(.+?\)/g, '');

    // cut off (...) and <...>
    for (let i = 0; i < name.length; i++) {
        switch (name[i]) {
            case '<':
                name = name.slice(0, i) + name.slice(findBalancePair(name, i + 1, '>') + 1);
                i--;
                break;
            case '(':
                name = name.slice(0, i) + name.slice(findBalancePair(name, i + 1, ')') + 1);
                i--;
                break;
        }
    }

    // cut off a types in prefix, i.e. void FunctionName
    const wsIndex = name.lastIndexOf(' ');
    name = wsIndex !== -1
        ? name.slice(wsIndex + 1)
        : name;

    return name;
}

function parseLoc(url: string) {
    const locMatch = url.match(/\:(\d+)\:(\d+)$/);
    const loc = locMatch ? locMatch[0] : null;
    const line = locMatch !== null ? Number(locMatch[1]) : -1;
    const column = locMatch !== null ? Number(locMatch[2]) : -1;

    return { loc, line, column };
}

// A function name could contain surrounding whitespaces or a get/set prefix for getters/setters
function cleanupFunctionName(name: string) {
    return name.trim().replace(/^(?:get |set )(\S)/, '$1');
}

function parseJsName(name: string, script?: Script): ParseJsNameResult {
    if (name.startsWith('wasm-function')) {
        script = { url: 'wasm://wasm/' + name } as Script;
        name += ' ' + script.url;
    }

    const scriptUrl = script?.url || null;

    if (scriptUrl === '' || scriptUrl === '<unknown>') {
        const { loc, line, column } = parseLoc(name);

        return {
            functionName: cleanupFunctionName(loc !== null ? name.slice(0, -loc.length) : name),
            scriptUrl: '',
            line,
            column
        };
    }

    // robust way since name and url could contain white spaces
    if (scriptUrl !== null) {
        const [prefix, loc = ''] = name.split(scriptUrl);
        const { line, column } = parseLoc(loc);

        return {
            functionName: cleanupFunctionName(prefix),
            scriptUrl,
            line,
            column
        };
    }

    // fallback when no script
    const nameMatch = name.match(/^(?:get |set )?([#.<>\[\]_$a-zA-Z\xA0-\uFFFF][#.<>\[\]\-_$a-zA-Z0-9\xA0-\uFFFF]*) /);
    const functionName = nameMatch !== null ? nameMatch[1] : '';
    const url = nameMatch !== null
        ? name.slice(nameMatch[0].length)
        : name[0] === ' ' ? name.slice(1) : name;
    const { loc, line, column } = parseLoc(url);

    return {
        functionName,
        scriptUrl: loc !== null ? url.slice(0, -loc.length) : url,
        line,
        column
    };
}

function functionTier(kind: Code['kind']) {
    switch (kind) {
        case 'Builtin':
        case 'Ignition':
        case 'Unopt':
            return 'Ignition';

        case 'Baseline':
        case 'Sparkplug':
            return 'Sparkplug';

        case 'Maglev':
            return 'Maglev';

        case 'Turboprop':
            return 'Turboprop';

        case 'Opt':
        case 'Turbofan':
            return 'Turbofan';

        default:
            return 'Unknown';
    }
}

function codeToCallFrameInfo(code: Code, scripts: Script[]): CodeCallFrameInfo {
    if (!code || !code.type) {
        return {
            name: '(unknown)'
        };
    }

    let name = code.name;
    let lowlevel = false;

    switch (code.type) {
        case 'CPP': {
            if (name[1] === ' ') {
                name = cleanupInternalName(name.slice(2));
            }
            break;
        }

        case 'SHARED_LIB': {
            // FIXME: there is no way in cpuprofile to express shared libs at the moment,
            // so represent them as (program) for now
            name = '(LIB) ' + name; // '(program)';
            lowlevel = true;
            break;
        }

        case 'JS': {
            const scriptId = code.source?.script;
            const script = typeof scriptId === 'number' ? scripts?.[scriptId] : undefined;
            const { functionName, scriptUrl, line, column } = parseJsName(name, script);

            return {
                name: functionName,
                file: scriptUrl,
                line,
                column
            };
        }

        case 'CODE': {
            switch (code.kind) {
                case 'LoadIC':
                case 'StoreIC':
                case 'KeyedStoreIC':
                case 'KeyedLoadIC':
                case 'LoadGlobalIC':
                case 'Handler':
                    name = '(IC) ' + name;
                    lowlevel = true;
                    break;

                case 'BytecodeHandler':
                    name = '(bytecode) ~' + name;
                    lowlevel = true;
                    break;

                case 'Stub':
                    name = '(stub) ' + name;
                    lowlevel = true;
                    break;

                case 'Builtin':
                    name = '(builtin) ' + name;
                    lowlevel = true;
                    break;

                case 'RegExp':
                    name = 'RegExp: ' + name;
                    break;
            }

            break;
        }

        default: {
            name = `(${code.type}) ${name}`;
        }
    }

    return { name, lowlevel };
}

function createCallFrame(
    functionName: string,
    url = '',
    lineNumber = -1,
    columnNumber = -1,
    scriptId = 0,
    functionId: number | null = null
): CallFrame {
    return {
        scriptId,
        functionId,
        functionName,
        url,
        lineNumber,
        columnNumber
    };
}

function createNode(id: number, callFrame: CallFrame): Node {
    return {
        id,
        callFrame,
        children: []
    };
}

function processFunctionCodes(v8log: V8LogProfile, codes: number[]) {
    return codes.map(codeIndex => {
        const code = v8log.code[codeIndex];
        const codeSource = code.source || null;

        return {
            tm: code.tm || 0,
            tier: functionTier(code.kind),
            positions: codeSource?.positions || '',
            inlined: codeSource?.inlined || '',
            fns: codeSource?.fns || []
        };
    });
}

export function isV8Log(data: Record<string, unknown>) {
    if (
        data && typeof data === 'object' &&
        Array.isArray(data.code) &&
        Array.isArray(data.functions) &&
        Array.isArray(data.ticks)) {
        return true;
    }

    return false;
}

export function convertV8LogIntoCpuprofile(v8log: V8LogProfile): V8CpuProfile {
    const scriptIdByUrl = new Map<string, number>([['', 0]]);
    const getScriptIdByUrl = (url: string) => scriptIdByUrl.has(url)
        ? scriptIdByUrl.get(url)
        : scriptIdByUrl.set(url, scriptIdByUrl.size).size - 1;
    const vmStateIgnoreStack = new Uint32Array(vmState.length);
    const vmStateCallFrames = vmState.map(name =>
        name !== 'js'
            ? createCallFrame(`(${
                // https://github.com/v8/v8/blob/2be84efd933f6e1e29b0c508a1035ed7d13d7127/src/profiler/symbolizer.cc#L34
                name == 'other' || name === 'external' || name === 'logging'
                    ? 'program'
                    : name
            })`)
            : null
    );
    const rootCallFrame = createCallFrame('(root)');
    const programCallFrame = createCallFrame('(program)');
    const callFrameById = new Map<number, CallFrame | null>();
    const rootNode = createNode(1, rootCallFrame);
    const rootNodeMap = new Map();
    const nodes = [rootNode];
    const nodesTransition = new Map<number, Map<CallFrame, Node>>([[1, rootNodeMap]]);
    let nodeIdSeed = 1;
    let lastTm = 0;
    const scripts: V8CpuProfileScript[] = [];
    const scriptFunctions: V8CpuProfileScriptFunction[] = [];
    const profile: V8CpuProfile = {
        startTime: 0,
        endTime: 0,
        nodes,
        timeDeltas: new Array(v8log.ticks.length),
        samples: new Array(v8log.ticks.length),
        scripts,
        scriptFunctions
    };

    vmStateIgnoreStack[VM_STATE_GC] = 1; // FIXME: probably stack is available on GC, but in cpuprofile GC is always on root
    vmStateIgnoreStack[VM_STATE_IDLE] = 1;

    v8log.ticks.sort((a, b) => a.tm - b.tm);

    for (let tickIndex = 0; tickIndex < v8log.ticks.length; tickIndex++) {
        const tick = v8log.ticks[tickIndex];
        let vmStateCallFrame = vmStateCallFrames[tick.vm];
        let currentNode = rootNode;
        let currentNodeMap = rootNodeMap;

        if (vmStateIgnoreStack[tick.vm] !== 1) {
            for (let i = tick.s.length - 2; i >= 0; i -= 2) {
                const id = tick.s[i];

                if (id === -1) {
                    continue;
                }

                let callFrame = callFrameById.get(id);

                if (callFrame === undefined) {
                    if (id > v8log.code.length) {
                        // treat unknown ids as a memory address
                        callFrame = createCallFrame(`0x${id.toString(16)}`);
                    } else {
                        const code = v8log.code[id];

                        // FIXME: ignore Abort.Wide/ExtraWide for now since it too noisy;
                        // not sure what it stands for, but looks like an execution pause
                        if (code.kind === 'BytecodeHandler') {
                            if (code.name === 'Abort.Wide' || code.name === 'Abort.ExtraWide') {
                                continue;
                            }
                        }

                        const { name, file, line, column, lowlevel } = codeToCallFrameInfo(code, v8log.scripts);
                        callFrame = lowlevel ? null : createCallFrame(
                            name,
                            file,
                            line,
                            column,
                            code.source ? code.source.script : getScriptIdByUrl(file || ''),
                            typeof code.func === 'number' ? code.func : null
                        );
                    }

                    callFrameById.set(id, callFrame);
                }

                // skip ignored call frames
                if (callFrame === null) {
                    continue;
                }

                let nextNode = currentNodeMap.get(callFrame);

                if (nextNode === undefined) {
                    nextNode = createNode(++nodeIdSeed, callFrame);
                    nodes.push(nextNode);
                    currentNodeMap.set(callFrame, nextNode);
                    currentNode.children.push(nextNode.id);
                    nodesTransition.set(nodeIdSeed, currentNodeMap = new Map());
                } else {
                    currentNodeMap = nodesTransition.get(nextNode.id) as Map<CallFrame, Node>;
                }

                currentNode = nextNode;
            }
        }

        if (vmStateCallFrame === null && currentNode === rootNode) {
            // v8 profiler uses (program) in case no stack captured
            // https://github.com/v8/v8/blob/2be84efd933f6e1e29b0c508a1035ed7d13d7127/src/profiler/symbolizer.cc#L174
            vmStateCallFrame = programCallFrame;
        }

        if (vmStateCallFrame !== null) {
            let node = currentNodeMap.get(vmStateCallFrame);

            if (node === undefined) {
                node = createNode(++nodeIdSeed, vmStateCallFrame);
                nodes.push(node);
                currentNodeMap.set(vmStateCallFrame, node);
                currentNode.children.push(node.id);
                nodesTransition.set(nodeIdSeed, new Map());
            }

            currentNode = node;
        }

        profile.samples[tickIndex] = currentNode.id;
        profile.timeDeltas[tickIndex] = tick.tm - lastTm;

        lastTm = tick.tm;
    }

    const samplesInterval = profile.timeDeltas.slice().sort()[profile.timeDeltas.length >> 1];
    profile._samplesInterval = samplesInterval;
    profile.endTime = lastTm + samplesInterval;

    const scriptIdToIndex = new Map<number, number>();
    for (const { id, url, source } of v8log.scripts.filter(Boolean)) {
        scriptIdToIndex.set(id, scripts.length);
        scripts.push({
            id,
            // treat <unknown> urls as empty strings which is better for futher processing
            url: url === '<unknown>'
                ? ''
                // FIXME: deno wraps rust paths in brackets, e.g. [ext:cli/worker.rs:191:37]
                // unwrap bracket's content for now, but looks like there should be a better solution
                : url[0] === '[' && url[url.length - 1] === ']'
                    ? url.slice(1, -1)
                    : url,
            source
        });
    }

    for (let i = 0, k = 0, prev: ProfileFunction | null = null; i < v8log.functions.length; i++) {
        const fn = v8log.functions[i];
        const source = v8log.code[fn.codes[0]].source; // all the function codes have the same reference to script source

        if (!source) {
            // wasm functions and some other has no source
            // console.log(fn, fn.codes.map(x => v8log.code[x]));
            continue;
        }

        const { functionName, line, column } = parseJsName(fn.name, v8log.scripts[source.script]);

        // V8 usually adds a first-pass parsing state of a module as a separate function, followed by a fully parsed state function;
        // in that case, merge script function entries into a single function with concatenated states
        if (prev !== null && prev.name === fn.name && line === 1 && column === 1) {
            scriptFunctions[k - 1].states.push(...processFunctionCodes(v8log, fn.codes));
            continue;
        }

        scriptFunctions[k++] = {
            id: k,
            name: functionName,
            script: scriptIdToIndex.get(source.script) ?? null,
            start: source.start,
            end: source.end,
            line,
            column,
            states: processFunctionCodes(v8log, fn.codes)
        };

        prev = fn;
    }

    return profile;
}
