function createBytecodeHandler(name: string, params: string[], description: string) {
    return {
        name,
        params,
        description
    };
}

export const bytecodeHandlers = [
    createBytecodeHandler('Abort', ['abort_reason'], 'Aborts execution with a runtime error.'),
    createBytecodeHandler('Add', ['src', 'feedback_slot'], 'Adds the value in register `src` to the accumulator using feedback in `feedback_slot`.'),
    createBytecodeHandler('AddSmi', ['imm', 'feedback_slot'], 'Adds the immediate value `imm` to the accumulator using feedback in `feedback_slot`.'),
    createBytecodeHandler('BitwiseAnd', ['src', 'feedback_slot'], 'Performs a bitwise AND of the accumulator and register `src` using feedback in `feedback_slot`.'),
    createBytecodeHandler('BitwiseAndSmi', ['imm', 'feedback_slot'], 'Performs a bitwise AND of the accumulator and immediate value `imm` using feedback in `feedback_slot`.'),
    createBytecodeHandler('BitwiseNot', [], 'Performs a bitwise NOT on the accumulator.'),
    createBytecodeHandler('BitwiseOr', ['src', 'feedback_slot'], 'Performs a bitwise OR of the accumulator and register `src` using feedback in `feedback_slot`.'),
    createBytecodeHandler('BitwiseOrSmi', ['imm', 'feedback_slot'], 'Performs a bitwise OR of the accumulator and immediate value `imm` using feedback in `feedback_slot`.'),
    createBytecodeHandler('BitwiseXor', ['src', 'feedback_slot'], 'Performs a bitwise XOR of the accumulator and register `src` using feedback in `feedback_slot`.'),
    createBytecodeHandler('BitwiseXorSmi', ['imm', 'feedback_slot'], 'Performs a bitwise XOR of the accumulator and immediate value `imm` using feedback in `feedback_slot`.'),
    createBytecodeHandler('Call', ['callable', 'receiver', 'arg_count', 'feedback_slot'], 'Calls the JSFunction or Callable in register `callable` with receiver in register `receiver` and `arg_count` arguments in subsequent registers. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallAnyReceiver', ['callable', 'receiver', 'arg_count', 'feedback_slot'], 'Calls a JSFunction or Callable in register `callable` with receiver in register `receiver` and `arg_count` arguments in subsequent registers. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallJSRuntime', ['context_index', 'receiver', 'arg_count'], 'Calls the JS runtime function specified by `context_index` with receiver in register `receiver` and `arg_count` arguments in subsequent registers.'),
    createBytecodeHandler('CallProperty', ['receiver', 'arg_count', 'feedback_slot'], 'Calls a property function on `receiver` with `arg_count` arguments in subsequent registers. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallProperty0', ['receiver', 'feedback_slot'], 'Calls a property function on `receiver` with no arguments. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallProperty1', ['receiver', 'arg0', 'feedback_slot'], 'Calls a property function on `receiver` with one argument `arg0`. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallProperty2', ['receiver', 'arg0', 'arg1', 'feedback_slot'], 'Calls a property function on `receiver` with two arguments: `arg0` and `arg1`. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallRuntime', ['function_id', 'first_arg', 'arg_count'], 'Calls the runtime function `function_id` with arguments starting at register `first_arg` (`arg_count` arguments).'),
    createBytecodeHandler('CallRuntimeForPair', ['function_id', 'first_arg', 'arg_count', 'first_return'], 'Calls the runtime function `function_id` returning a pair, with arguments starting at `first_arg` (`arg_count` arguments). Stores results in `first_return` and `first_return + 1`.'),
    createBytecodeHandler('CallUndefinedReceiver', ['callable', 'arg_count', 'feedback_slot'], 'Calls the JSFunction or Callable in register `callable` with undefined as receiver and `arg_count` arguments in subsequent registers. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallUndefinedReceiver0', ['callable', 'feedback_slot'], 'Calls the JSFunction or Callable in register `callable` with undefined as receiver and no arguments. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallUndefinedReceiver1', ['callable', 'arg0', 'feedback_slot'], 'Calls the JSFunction or Callable in register `callable` with undefined as receiver and one argument `arg0`. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallUndefinedReceiver2', ['callable', 'arg0', 'arg1', 'feedback_slot'], 'Calls the JSFunction or Callable in register `callable` with undefined as receiver and two arguments: `arg0`, `arg1`. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CallWithSpread', ['callable', 'first_arg', 'arg_count', 'feedback_slot'], 'Calls the JSFunction or Callable in register `callable` with receiver in `first_arg` and `arg_count - 1` arguments in subsequent registers. The last argument is always a spread. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CloneObject', ['source_idx', 'flags', 'feedback_slot'], 'Allocates a new JSObject, copying enumerable own properties from the object in constant pool at `source_idx`. Feedback collected in `feedback_slot`.'),
    createBytecodeHandler('Construct', ['constructor', 'first_arg', 'arg_count', 'feedback_slot'], 'Invokes the constructor in register `constructor` with the first argument in `first_arg` and `arg_count` arguments in subsequent registers. The new.target is in the accumulator. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('ConstructForwardAllArgs', ['constructor', 'feedback_slot'], 'Invokes the constructor in register `constructor` with arguments implicitly forwarded from the caller. The new.target is in the accumulator. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('ConstructWithSpread', ['constructor', 'first_arg', 'arg_count', 'feedback_slot'], 'Invokes the constructor in register `constructor` with the first argument in `first_arg` and `arg_count` arguments in subsequent registers. The last argument is always a spread. The new.target is in the accumulator. Collects feedback in `feedback_slot`.'),
    createBytecodeHandler('CreateArrayFromIterable', [], 'Spreads the iterable from the accumulator into a new JSArray.'),
    createBytecodeHandler('CreateArrayLiteral', ['element_idx', 'literal_idx', 'flags'], 'Creates an array literal for literal index `literal_idx` with flags `flags` and constant elements in `element_idx`.'),
    createBytecodeHandler('CreateBlockContext', ['index'], 'Creates a new block context with the scope info constant at `index`.'),
    createBytecodeHandler('CreateCatchContext', ['exception', 'scope_info_idx'], 'Creates a new catch block context with `exception` in a register and scope info at `scope_info_idx`.'),
    createBytecodeHandler('CreateClosure', ['index', 'slot', 'flags'], 'Creates a new closure for SharedFunctionInfo at constant pool position `index` with pretenuring controlled by `flags`.'),
    createBytecodeHandler('CreateEmptyArrayLiteral', ['literal_idx'], 'Creates an empty JSArray literal for literal index `literal_idx`.'),
    createBytecodeHandler('CreateEmptyObjectLiteral', [], 'Creates an empty JSObject literal.'),
    createBytecodeHandler('CreateEvalContext', ['scope_info_idx', 'slots'], 'Creates a new context for an eval closure, with scope info at `scope_info_idx` and `slots` variables.'),
    createBytecodeHandler('CreateFunctionContext', ['scope_info_idx', 'slots'], 'Creates a new context for a function closure, with scope info at `scope_info_idx` and `slots` variables.'),
    createBytecodeHandler('CreateMappedArguments', [], 'Creates a new mapped arguments object.'),
    createBytecodeHandler('CreateObjectLiteral', ['element_idx', 'literal_idx', 'flags'], 'Creates an object literal for literal index `literal_idx` with flags `flags` and constant elements in `element_idx`.'),
    createBytecodeHandler('CreateRegExpLiteral', ['pattern_idx', 'literal_idx', 'flags'], 'Creates a regular expression literal for literal index `literal_idx` with pattern at `pattern_idx` and flags `flags`.'),
    createBytecodeHandler('CreateRestParameter', [], 'Creates a new rest parameter array.'),
    createBytecodeHandler('CreateUnmappedArguments', [], 'Creates a new unmapped arguments object.'),
    createBytecodeHandler('CreateWithContext', ['object', 'scope_info_idx'], 'Creates a new context for a with-statement using the object in register `object` and scope info at `scope_info_idx`.'),
    // DebugBreak0-DebugBreak6 autogenerated
    ...Array.from({ length: 7 }, (_, i) =>
        createBytecodeHandler('DebugBreak' + i, [], `Inserts a debug break with ${i || 'zero'} operand slot${i !== 1 ? 's' : ''}. Used for debugging.`)
    ),
    createBytecodeHandler('DebugBreakExtraWide', [], 'Inserts a debug break with extra-wide (32-bit) operand support. Used for debugging.'),
    createBytecodeHandler('DebugBreakWide', [], 'Inserts a debug break with wide (16-bit) operand support. Used for debugging.'),
    createBytecodeHandler('Debugger', [], 'Calls the runtime to handle a debugger statement.'),
    createBytecodeHandler('Dec', ['feedback_slot'], 'Decrements the accumulator by one using feedback in `feedback_slot`.'),
    createBytecodeHandler('DefineKeyedOwnProperty', ['object', 'key', 'flags', 'feedback_slot'], 'Defines an own property on `object` with key `key` and value from the accumulator. Flags in `flags`. Uses feedback in `feedback_slot`.'),
    createBytecodeHandler('DefineKeyedOwnPropertyInLiteral', ['object', 'name', 'flags', 'feedback_slot'], 'Defines a property `name` in `object` with value from the accumulator. Property attributes and set_function_name flag in `flags`. Feedback in `feedback_slot`.'),
    createBytecodeHandler('DefineNamedOwnProperty', ['object', 'name_index', 'feedback_slot'], 'Defines an own property on `object` with name from constant pool entry `name_index` and value from the accumulator. Feedback in `feedback_slot`.'),
    createBytecodeHandler('DeletePropertySloppy', ['object'], 'Deletes the property specified in the accumulator from `object` using sloppy mode semantics.'),
    createBytecodeHandler('DeletePropertyStrict', ['object'], 'Deletes the property specified in the accumulator from `object` using strict mode semantics.'),
    createBytecodeHandler('Div', ['src', 'feedback_slot'], 'Divides the accumulator by the value in register `src` using feedback in `feedback_slot`.'),
    createBytecodeHandler('DivSmi', ['imm', 'feedback_slot'], 'Divides the accumulator by the immediate value `imm` using feedback in `feedback_slot`.'),
    createBytecodeHandler('Exp', ['src', 'feedback_slot'], 'Raises the accumulator to the power of the value in register `src` using feedback in `feedback_slot`.'),
    createBytecodeHandler('ExpSmi', ['imm', 'feedback_slot'], 'Raises the accumulator to the power of the immediate value `imm` using feedback in `feedback_slot`.'),
    createBytecodeHandler('ExtraWide', [], 'Prefix bytecode indicating the next bytecode has extra-wide (32-bit) operands.'),
    createBytecodeHandler('FindNonDefaultConstructorOrConstruct', ['this_function', 'new_target', 'output'], 'Walks the prototype chain from `this_function`\'s super constructor, storing results in `output`.'),
    createBytecodeHandler('ForInContinue', ['index', 'cache_length'], 'Returns false if the end of the enumerable properties has been reached.'),
    createBytecodeHandler('ForInEnumerate', ['receiver'], 'Enumerates enumerable keys of `receiver` and stores keys to enumerate in the accumulator.'),
    createBytecodeHandler('ForInNext', ['receiver', 'index', 'cache_info_pair', 'feedback_slot'], 'Returns the next enumerable property in the accumulator.'),
    createBytecodeHandler('ForInPrepare', ['cache_info_triple'], 'Prepares state for for..in loop execution, writing results into registers starting at `cache_info_triple`.'),
    createBytecodeHandler('ForInStep', ['index'], 'Increments the loop counter in register `index` and stores the result in the accumulator.'),
    createBytecodeHandler('GetEnumeratedKeyedProperty', ['receiver', 'index', 'feedback_slot'], 'Loads the property at index `index` from `receiver` into the accumulator using feedback in `feedback_slot`. Used for enumerator-based property access.'),
    createBytecodeHandler('GetIterator', ['object'], 'Retrieves and calls object[Symbol.iterator], storing the result in the accumulator. Throws if result is not a JSReceiver.'),
    createBytecodeHandler('GetKeyedProperty', ['object', 'feedback_slot'], 'Loads a property from `object` with the key in the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('GetNamedProperty', ['object', 'name_index', 'feedback_slot'], 'Loads a property from `object` with the name from constant pool entry `name_index`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('GetNamedPropertyFromSuper', ['receiver', 'name_index', 'feedback_slot'], 'Loads a property from the prototype of `receiver` (super), name from constant pool entry `name_index`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('GetSuperConstructor', [], 'Gets the super constructor from the object referenced by the accumulator.'),
    createBytecodeHandler('GetTemplateObject', ['descriptor_idx', 'literal_idx'], 'Creates and returns the template object for tagged templates, using descriptor at `descriptor_idx` and literal at `literal_idx`.'),
    createBytecodeHandler('Illegal', [], 'Invalid bytecode; aborts execution if dispatched.'),
    createBytecodeHandler('Inc', ['feedback_slot'], 'Increments the accumulator by one using feedback in `feedback_slot`.'),
    createBytecodeHandler('IncBlockCounter', ['slot'], 'Increments the execution count for the given slot (used for code coverage).'),
    createBytecodeHandler('InvokeIntrinsic', ['function_id', 'first_arg', 'arg_count'], 'Calls the intrinsic function `function_id` with arguments starting at `first_arg` (`arg_count` arguments).'),
    createBytecodeHandler('Jump', ['imm'], 'Jumps by the number of bytes specified by the immediate operand `imm`.'),
    createBytecodeHandler('JumpConstant', ['idx'], 'Jumps by the number of bytes from the Smi at constant pool entry `idx`.'),
    createBytecodeHandler('JumpIfFalse', ['imm'], 'Jumps by the immediate offset if the accumulator is false (requires a boolean).'),
    createBytecodeHandler('JumpIfFalseConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry `idx` if the accumulator is false (requires a boolean).'),
    createBytecodeHandler('JumpIfForInDone', ['imm', 'index', 'cache_length'], 'Jumps by the immediate offset `imm` if the value in register `index` is greater than or equal to the end index for ForIn enumeration.'),
    createBytecodeHandler('JumpIfForInDoneConstant', ['idx', 'index', 'cache_length'], 'Jumps by the number of bytes in the Smi at constant pool entry `idx` if the value in register `index` is greater than or equal to the end index for ForIn enumeration.'),
    createBytecodeHandler('JumpIfJSReceiver', ['imm'], 'Jumps by the immediate offset if the accumulator is a JSReceiver.'),
    createBytecodeHandler('JumpIfJSReceiverConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry `idx` if the accumulator is a JSReceiver.'),
    createBytecodeHandler('JumpIfNotNull', ['imm'], 'Jumps by the immediate offset if the accumulator is not null.'),
    createBytecodeHandler('JumpIfNotNullConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry `idx` if the accumulator is not null.'),
    createBytecodeHandler('JumpIfNotUndefined', ['imm'], 'Jumps by the immediate offset if the accumulator is not undefined.'),
    createBytecodeHandler('JumpIfNotUndefinedConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry `idx` if the accumulator is not undefined.'),
    createBytecodeHandler('JumpIfNull', ['imm'], 'Jumps by the immediate offset if the accumulator is null.'),
    createBytecodeHandler('JumpIfNullConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry `idx` if the accumulator is null.'),
    createBytecodeHandler('JumpIfToBooleanFalse', ['imm'], 'Jumps by the immediate offset if the accumulator coerces to false.'),
    createBytecodeHandler('JumpIfToBooleanFalseConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry idx if the accumulator coerces to false.'),
    createBytecodeHandler('JumpIfToBooleanTrue', ['imm'], 'Jumps by the immediate offset if the accumulator coerces to true.'),
    createBytecodeHandler('JumpIfToBooleanTrueConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry idx if the accumulator coerces to true.'),
    createBytecodeHandler('JumpIfTrue', ['imm'], 'Jumps by the immediate offset if the accumulator is true (requires a boolean).'),
    createBytecodeHandler('JumpIfTrueConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry idx if the accumulator is true (requires a boolean).'),
    createBytecodeHandler('JumpIfUndefined', ['imm'], 'Jumps by the immediate offset if the accumulator is undefined.'),
    createBytecodeHandler('JumpIfUndefinedConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry idx if the accumulator is undefined.'),
    createBytecodeHandler('JumpIfUndefinedOrNull', ['imm'], 'Jumps by the immediate offset if the accumulator is undefined or null.'),
    createBytecodeHandler('JumpIfUndefinedOrNullConstant', ['idx'], 'Jumps by the offset from the Smi at constant pool entry idx if the accumulator is undefined or null.'),
    createBytecodeHandler('JumpLoop', ['imm', 'loop_depth', 'feedback_slot'], 'Performs a backward jump by offset imm, performing loop nesting and stack checks. May trigger OSR.'),
    createBytecodeHandler('LdaConstant', ['idx'], 'Loads the constant literal at constant pool entry `idx` into the accumulator.'),
    createBytecodeHandler('LdaContextSlot', ['context', 'slot_index', 'depth'], 'Loads the value from context `context`, slot `slot_index`, at depth `depth` into the accumulator.'),
    createBytecodeHandler('LdaCurrentContextSlot', ['slot_index'], 'Loads the value from the current context slot `slot_index` into the accumulator.'),
    createBytecodeHandler('LdaCurrentScriptContextSlot', ['slot_index'], 'Loads the value from the current script context slot `slot_index` into the accumulator.'),
    createBytecodeHandler('LdaFalse', [], 'Loads the boolean value `false` into the accumulator.'),
    createBytecodeHandler('LdaGlobal', ['name_index', 'feedback_slot'], 'Loads the global variable with name from constant pool entry `name_index` into the accumulator, using feedback in `feedback_slot` (outside typeof).'),
    createBytecodeHandler('LdaGlobalInsideTypeof', ['name_index', 'feedback_slot'], 'Loads the global variable with name from constant pool entry `name_index` into the accumulator, using feedback in `feedback_slot` (inside typeof).'),
    createBytecodeHandler('LdaImmutableContextSlot', ['context', 'slot_index', 'depth'], 'Loads the immutable value from context `context`, slot `slot_index`, at depth `depth` into the accumulator.'),
    createBytecodeHandler('LdaImmutableCurrentContextSlot', ['slot_index'], 'Loads the immutable value from the current context slot `slot_index` into the accumulator.'),
    createBytecodeHandler('LdaLookupContextSlot', ['name_index'], 'Dynamically looks up the variable with name from constant pool entry `name_index` in the context chain and loads it into the accumulator.'),
    createBytecodeHandler('LdaLookupContextSlotInsideTypeof', ['name_index'], 'Dynamically looks up the variable with name from constant pool entry `name_index` in the context chain and loads it into the accumulator, suppressing ReferenceError (inside typeof).'),
    createBytecodeHandler('LdaLookupGlobalSlot', ['name_index', 'feedback_slot', 'depth'], 'Dynamically looks up the global variable with name from constant pool entry `name_index` at context chain depth `depth`, using feedback in `feedback_slot`, and loads it into the accumulator.'),
    createBytecodeHandler('LdaLookupGlobalSlotInsideTypeof', ['name_index', 'feedback_slot', 'depth'], 'Dynamically looks up the global variable with name from constant pool entry `name_index` at context chain depth `depth`, using feedback in `feedback_slot`, and loads it into the accumulator, suppressing ReferenceError (inside typeof).'),
    createBytecodeHandler('LdaLookupScriptContextSlot', ['name_index'], 'Dynamically looks up the variable with name from constant pool entry `name_index` in the script context and loads it into the accumulator.'),
    createBytecodeHandler('LdaLookupScriptContextSlotInsideTypeof', ['name_index'], 'Dynamically looks up the variable with name from constant pool entry `name_index` in the script context and loads it into the accumulator, suppressing ReferenceError (inside typeof).'),
    createBytecodeHandler('LdaLookupSlot', ['name_index'], 'Dynamically looks up the variable with name from constant pool entry `name_index` and loads it into the accumulator.'),
    createBytecodeHandler('LdaLookupSlotInsideTypeof', ['name_index'], 'Dynamically looks up the variable with name from constant pool entry `name_index` and loads it into the accumulator, suppressing ReferenceError (inside typeof).'),
    createBytecodeHandler('LdaModuleVariable', ['cell_index', 'depth'], 'Loads the contents of a module variable identified by `cell_index` at context depth `depth` into the accumulator.'),
    createBytecodeHandler('LdaNull', [], 'Loads the value `null` into the accumulator.'),
    createBytecodeHandler('LdaScriptContextSlot', ['context_index', 'slot_index'], 'Loads the value from script context identified by `context_index` and slot `slot_index` into the accumulator.'),
    createBytecodeHandler('LdaSmi', ['imm'], 'Loads the immediate Smi value `imm` into the accumulator.'),
    createBytecodeHandler('LdaTheHole', [], 'Loads the special value TheHole into the accumulator.'),
    createBytecodeHandler('LdaTrue', [], 'Loads the boolean value `true` into the accumulator.'),
    createBytecodeHandler('LdaUndefined', [], 'Loads the value `undefined` into the accumulator.'),
    createBytecodeHandler('LdaZero', [], 'Loads the Smi value `0` into the accumulator.'),
    createBytecodeHandler('Ldar', ['src'], 'Loads the value from register `src` into the accumulator.'),
    createBytecodeHandler('LogicalNot', [], 'Performs logical NOT on the accumulator (expects a boolean).'),
    createBytecodeHandler('Mod', ['src', 'feedback_slot'], 'Computes the remainder of the accumulator divided by the value in register `src`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('ModSmi', ['imm', 'feedback_slot'], 'Computes the remainder of the accumulator divided by the immediate value `imm`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('Mov', ['src', 'dst'], 'Copies the value from register `src` to register `dst`.'),
    createBytecodeHandler('Mul', ['src', 'feedback_slot'], 'Multiplies the accumulator by the value in register `src`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('MulSmi', ['imm', 'feedback_slot'], 'Multiplies the accumulator by the immediate value `imm`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('Negate', ['feedback_slot'], 'Negates the value in the accumulator using feedback in `feedback_slot`.'),
    createBytecodeHandler('PopContext', ['context'], 'Pops the current context and sets `context` as the new context.'),
    createBytecodeHandler('PushContext', ['context'], 'Pushes the value in the accumulator as the new current context, saving the previous context in `context`.'),
    createBytecodeHandler('ReThrow', [], 'Re-throws the exception in the accumulator.'),
    createBytecodeHandler('ResumeGenerator', ['generator', 'first_output_register', 'register_count'], 'Imports the register file stored in the generator, writing `register_count` registers to the frame starting at `first_output_register`, and marks the generator as executing.'),
    createBytecodeHandler('Return', [], 'Returns the value in the accumulator.'),
    createBytecodeHandler('SetKeyedProperty', ['object', 'key', 'feedback_slot'], 'Stores the value in the accumulator as a property of `object` with key `key`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('SetNamedProperty', ['object', 'name_index', 'feedback_slot'], 'Stores the value in the accumulator as a property of `object` with name from constant pool entry `name_index`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('SetPendingMessage', [], 'Sets the pending message to the value in the accumulator, returning the previous pending message in the accumulator.'),
    createBytecodeHandler('ShiftLeft', ['src', 'feedback_slot'], 'Shifts the value in register `src` to the left by the count in the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('ShiftLeftSmi', ['imm', 'feedback_slot'], 'Shifts the accumulator to the left by the immediate value `imm`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('ShiftRight', ['src', 'feedback_slot'], 'Arithmetic right shift of register `src` by the count in the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('ShiftRightLogical', ['src', 'feedback_slot'], 'Logical right shift of register `src` by the count in the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('ShiftRightLogicalSmi', ['imm', 'feedback_slot'], 'Logical right shift of the accumulator by the immediate value `imm`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('ShiftRightSmi', ['imm', 'feedback_slot'], 'Arithmetic right shift of the accumulator by the immediate value `imm`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('StaContextSlot', ['context', 'slot_index', 'depth'], 'Stores the value in the accumulator into context `context`, slot `slot_index`, at depth `depth`.'),
    createBytecodeHandler('StaCurrentContextSlot', ['slot_index'], 'Stores the value in the accumulator into the current context slot `slot_index`.'),
    createBytecodeHandler('StaCurrentScriptContextSlot', ['slot_index'], 'Stores the value in the accumulator into the current script context slot `slot_index`.'),
    createBytecodeHandler('StaGlobal', ['name_index', 'feedback_slot'], 'Stores the value in the accumulator into the global variable with name from constant pool entry `name_index`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('StaInArrayLiteral', ['array', 'index', 'feedback_slot'], 'Stores the value in the accumulator into `array` at `index`, using feedback in `feedback_slot`.'),
    createBytecodeHandler('StaLookupSlot', ['name_index', 'flags'], 'Stores the value in the accumulator into the variable with name from constant pool entry `name_index`, with flags `flags`.'),
    createBytecodeHandler('StaModuleVariable', ['cell_index', 'depth'], 'Stores the value in the accumulator into the module variable identified by `cell_index` at context depth `depth`.'),
    createBytecodeHandler('StaScriptContextSlot', ['context_index', 'slot_index'], 'Stores the value in the accumulator into script context `context_index`, slot `slot_index`.'),
    createBytecodeHandler('Star', ['dst'], 'Stores the value in the accumulator into register `dst`.'),
    // Star0–Star15 autogenerated
    ...Array.from({ length: 16 }, (_, i) =>
        createBytecodeHandler(`Star${i}`, [], `Stores the value in the accumulator into register \`r${i}\``)
    ),
    createBytecodeHandler('Sub', ['src', 'feedback_slot'], 'Subtracts the value in register `src` from the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('SubSmi', ['imm', 'feedback_slot'], 'Subtracts the immediate value `imm` from the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('SuspendGenerator', ['generator', 'first_input_register', 'register_count', 'suspend_id'], 'Stores parameters and the register file in the generator, along with the current context, `suspend_id`, and bytecode offset. Returns the value in the accumulator.'),
    createBytecodeHandler('SwitchOnGeneratorState', ['generator', 'table_start', 'table_length'], 'If `generator` is undefined, falls through. Otherwise, dispatches on the generator\'s state using a jump table in the constant pool, starting at `table_start`, with `table_length` entries.'),
    createBytecodeHandler('SwitchOnSmiNoFeedback', ['table_start', 'table_length', 'case_value_base'], 'Jumps using a Smi jump table in the constant pool, indexed by (accumulator - `case_value_base`). Table starts at `table_start` with `table_length` entries.'),
    createBytecodeHandler('TestEqual', ['src', 'feedback_slot'], 'Tests if the value in register `src` equals the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TestEqualStrict', ['src', 'feedback_slot'], 'Tests if the value in register `src` is strictly equal to the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TestGreaterThan', ['src', 'feedback_slot'], 'Tests if the value in register `src` is greater than the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TestGreaterThanOrEqual', ['src', 'feedback_slot'], 'Tests if the value in register `src` is greater than or equal to the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TestIn', ['src', 'feedback_slot'], 'Tests if the value in register `src` is a property in the object in the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TestInstanceOf', ['src', 'feedback_slot'], 'Tests if the value in register `src` is an instance of the constructor in the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TestLessThan', ['src', 'feedback_slot'], 'Tests if the value in register `src` is less than the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TestLessThanOrEqual', ['src', 'feedback_slot'], 'Tests if the value in register `src` is less than or equal to the accumulator, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TestNull', [], 'Tests if the value in the accumulator is null.'),
    createBytecodeHandler('TestReferenceEqual', ['src'], 'Tests if the value in register `src` is reference-equal to the accumulator (simple reference or Smi equality).'),
    createBytecodeHandler('TestTypeOf', ['literal_flag'], 'Tests if the value in the accumulator has typeof equal to the literal represented by `literal_flag`.'),
    createBytecodeHandler('TestUndefined', [], 'Tests if the value in the accumulator is undefined.'),
    createBytecodeHandler('TestUndetectable', [], 'Tests if the value in the accumulator is undetectable (e.g., null, undefined, or document.all).'),
    createBytecodeHandler('Throw', [], 'Throws the exception in the accumulator.'),
    createBytecodeHandler('ThrowIfNotSuperConstructor', ['constructor'], 'Throws an exception if the value in `constructor` is not a constructor.'),
    createBytecodeHandler('ThrowReferenceErrorIfHole', ['variable_name'], 'Throws a ReferenceError if the value in the accumulator is TheHole.'),
    createBytecodeHandler('ThrowSuperAlreadyCalledIfNotHole', [], 'Throws a SuperAlreadyCalled exception if the value in the accumulator is not TheHole.'),
    createBytecodeHandler('ThrowSuperNotCalledIfHole', [], 'Throws an exception if the value in the accumulator is TheHole.'),
    createBytecodeHandler('ToBoolean', [], 'Converts the value in the accumulator to a boolean.'),
    createBytecodeHandler('ToBooleanLogicalNot', [], 'Performs logical NOT on the accumulator, first converting it to boolean if needed.'),
    createBytecodeHandler('ToName', ['dst'], 'Converts the value in the accumulator to a Name, storing the result in register `dst`.'),
    createBytecodeHandler('ToNumber', ['feedback_slot'], 'Converts the value in the accumulator to a number, using feedback in `feedback_slot`.'),
    createBytecodeHandler('ToNumeric', ['feedback_slot'], 'Converts the value in the accumulator to a numeric value, using feedback in `feedback_slot`.'),
    createBytecodeHandler('ToObject', ['dst'], 'Converts the value in the accumulator to a JSReceiver, storing the result in register `dst`.'),
    createBytecodeHandler('ToString', ['feedback_slot'], 'Converts the value in the accumulator to a String, using feedback in `feedback_slot`.'),
    createBytecodeHandler('TypeOf', [], 'Loads the type name of the value in the accumulator as a string.'),
    createBytecodeHandler('Wide', [], 'Prefix bytecode indicating the next bytecode has wide (16-bit) operand)')
];

export const bytecodeHandlersDict = Object.fromEntries(bytecodeHandlers.map(entry => [entry.name, entry]));
